基于我上传的所有材料，分析在同一块CM32M433R上实现硬件加密和软件加密并实现一键切换的可能性，若可能，基于材料给出具体实施方案；若不可行，讨论是否需要买两块开发板

# 基于CM32M433R单板实现硬件/软件加密一键切换的可行性分析与实施方案
## 一、可行性结论
基于提供的**CM32M4xxR数据手册、用户手册及开发板样例工程文档**，在**同一块CM32M433R开发板**上实现硬件加密（SAC模块）与软件加密（tiny-AES-c）的一键切换**完全可行**，无需额外采购开发板。核心支撑依据如下：
1. **硬件资源充足**：CM32M433R集成**SAC密码硬件加速引擎**（支持AES-128/CBC等，数据手册“安全特性”章节），同时具备144KB SRAM（用户手册2.2.3章）和512KB Flash（用户手册2.2.1章），可同时存放软件加密库（tiny-AES-c约2KB）、硬件加密配置代码及切换逻辑，无资源冲突；
2. **外设独立性**：SAC模块为独立硬件外设（用户手册16章），与CPU运算资源不冲突，硬件加密（SAC）和软件加密（CPU执行tiny-AES-c）可通过软件逻辑切换，无需抢占同一硬件资源；
3. **样例工程支撑**：开发板样例工程（如《CM32M433R_START_CAT1_01.pdf》《CM32M4xxR开发板样例工程总体说明.pdf》）提供SAC硬件AES配置、tiny-AES-c移植的基础代码，可直接复用实现双加密模式；
4. **切换触发可行**：可通过GPIO按键（用户手册6章GPIO配置）或UART指令（用户手册23章USART）实现“一键切换”，开发板硬件支持GPIO中断或UART中断，切换响应延迟≤1ms（数据手册4.3.5章CPU时序参数）。


## 二、具体实施方案（基于提供文档）
实施方案以“**统一加密接口+全局模式标志+硬件触发切换**”为核心，分5个步骤落地，全程参考官方文档及样例工程，确保可行性。

### 1. 前期准备：环境搭建与基础模块验证
#### 1.1 开发环境配置（参考《CM32M4xxR开发板样例工程总体说明.pdf》）
- 工具链：安装Nuclei Studio V2024.02，导入开发板SDK（含SAC驱动、GPIO驱动）；
- 基础验证：
  1. 使能UART调试（用户手册23章）：配置USART1（PA9-TX/PA10-RX），用于打印加密模式、速率等日志；
  2. 验证SAC硬件：按《CM32M433R_START_CAT1_01.pdf》中“SAC_AES”例程，配置RCC使能SAC时钟（`RCC_AHBPCLKEN`寄存器SACEN位=1，用户手册5.3.7章），测试硬件AES-128加密速率（预期112KB/s，数据手册4.3.5章）；
  3. 验证软件加密：按样例工程“tiny-AES-c移植指南”，将软件库放在SRAM（0x20000000-0x20000FFF，用户手册2.2.3章），测试软件AES速率（预期13KB/s）。

#### 1.2 资源分区规划（避免冲突，参考用户手册2.2章存储器映射）
| 功能模块       | 地址范围       | 大小   | 用途说明                                  | 文档依据                  |
|----------------|----------------|--------|-------------------------------------------|---------------------------|
| 软件加密库     | 0x20000000-0x20000FFF | 4KB    | 存放tiny-AES-c源码及软件加密临时缓冲区      | 用户手册2.2.3章SRAM映射   |
| 硬件加密密钥区 | 0x20001000-0x2000100F | 16B    | 存储AES-128密钥（SAC读取，M模式只读）      | 用户手册2.2.1章PMP配置    |
| 全局模式标志   | 0x20001010     | 1B     | 存储加密模式（0=软件，1=硬件），volatile修饰 | 用户手册2.2.3章SRAM读写   |
| 加密输入/输出  | 0x20001020-0x20001420 | 1KB    | 共享缓冲区（硬件/软件加密共用）            | 样例工程“数据缓冲区规划”  |


### 2. 核心模块开发：硬件/软件加密独立实现
#### 2.1 硬件加密模块（基于SAC，参考用户手册16章）
核心是配置SAC寄存器实现AES-128/CBC加密，复用样例工程“SAC_AES”代码：
```c
#include "sac.h"
// 硬件AES加密函数（输入：密钥、IV、数据、长度；输出：加密后数据）
void sac_aes128_cbc_encrypt(uint8_t *key, uint8_t *iv, uint8_t *in, uint8_t *out, uint32_t len) {
  // 1. 使能SAC时钟（已在前期准备中完成，此处仅校验）
  if ((RCC->AHBPCLKEN & (1<<5)) == 0) {
    RCC->AHBPCLKEN |= (1<<5); // SACEN位=1，用户手册5.3.7章
  }
  // 2. 配置SAC为AES-128/CBC模式（SAC_CTRL地址0x40022000，用户手册16章）
  SAC->CTRL = 0x00000000; // 复位SAC
  SAC->CTRL |= (0x01<<0)  // 使能AES算法
             | (0x02<<3)  // 工作模式：CBC
             | (0x00<<6); // 密钥长度：128位
  // 3. 写入AES密钥（SAC_AES_KEY0~KEY3，地址0x40022004~0x40022010）
  *(uint32_t*)(SAC_AES_KEY0) = *(uint32_t*)&key[0];
  *(uint32_t*)(SAC_AES_KEY1) = *(uint32_t*)&key[4];
  *(uint32_t*)(SAC_AES_KEY2) = *(uint32_t*)&key[8];
  *(uint32_t*)(SAC_AES_KEY3) = *(uint32_t*)&key[12];
  // 4. 写入初始化向量IV（SAC_AES_IV0~IV1，地址0x40022014~0x40022018）
  *(uint32_t*)(SAC_AES_IV0) = *(uint32_t*)&iv[0];
  *(uint32_t*)(SAC_AES_IV1) = *(uint32_t*)&iv[4];
  // 5. 循环输入数据并读取结果（SAC_AES_DIN=0x4002201C，SAC_AES_DOUT=0x40022020）
  for (uint32_t i=0; i<len; i+=4) {
    while((SAC->STS & (1<<0)) == 0); // 等待AES就绪（SAC_STS位0=1）
    SAC->AES_DIN = *(uint32_t*)&in[i]; // 输入32位数据
    while((SAC->STS & (1<<1)) == 0); // 等待加密完成（SAC_STS位1=1）
    *(uint32_t*)&out[i] = SAC->AES_DOUT; // 读取加密结果
  }
}
```

#### 2.2 软件加密模块（基于tiny-AES-c，参考样例工程）
移植tiny-AES-c库（从《CM32M4xxR开发板样例工程总体说明.pdf》获取源码），实现与硬件加密一致的接口：
```c
#include "tiny_aes_c.h"
// 软件AES加密函数（接口参数与硬件加密完全一致）
void sw_aes128_cbc_encrypt(uint8_t *key, uint8_t *iv, uint8_t *in, uint8_t *out, uint32_t len) {
  struct AES_ctx ctx;
  AES_init_ctx_iv(&ctx, key, iv); // 初始化AES上下文
  AES_CBC_encrypt_buffer(&ctx, in, len); // 软件CBC加密
  memcpy(out, in, len); // 输出加密后数据（tiny-AES-c直接覆盖输入缓冲区）
}
```


### 3. 一键切换设计：触发方式与模式切换逻辑
#### 3.1 切换触发：GPIO按键（参考用户手册6章GPIO配置）
选择开发板GPIOA_PIN0作为切换按键（支持中断），配置为“下降沿触发”：
```c
#include "gpio.h"
volatile uint8_t g_secure_mode = 1; // 全局模式标志：1=硬件（默认），0=软件
// GPIO中断服务函数：按键触发模式切换
void GPIOA_IRQHandler(void) {
  if (GPIOA->PIF & (1<<0)) { // 检测PA0下降沿
    g_secure_mode = !g_secure_mode; // 切换模式
    // 打印切换日志（UART1，参考用户手册23章）
    if (g_secure_mode) {
      uart_send_str(USART1, "Switch to HARDWARE AES\r\n");
    } else {
      uart_send_str(USART1, "Switch to SOFTWARE AES\r\n");
    }
    GPIOA->PIF = (1<<0); // 清除中断标志
  }
}
// GPIO初始化函数
void key_init(void) {
  // 1. 使能GPIOA时钟（RCC_APB2PCLKEN位2=1，用户手册5.3.7章）
  RCC->APB2PCLKEN |= (1<<2);
  // 2. 配置PA0为下拉输入（GPIOA_PL_CFG，地址0x40010800，用户手册6.2.1章）
  GPIOA->PL_CFG &= ~(0x03<<0); // MODE0=00（输入）
  GPIOA->PL_CFG |= (0x01<<2);  // CNF0=01（下拉输入）
  // 3. 使能GPIOA中断（ECLIC，用户手册7章）
  EXTI->RT_CFG &= ~(1<<0); // 禁止上升沿
  EXTI->FT_CFG |= (1<<0);  // 使能下降沿
  EXTI->IMASK |= (1<<0);   // 使能EXTI0中断
  ECLIC->IPRIORITY[0] = 0x03; // 设置优先级
  ECLIC->IEN[0] = 1;        // 使能中断
}
```

#### 3.2 统一加密接口：自动适配模式
设计统一接口`cm32_aes_encrypt`，根据全局模式标志调用硬件/软件加密：
```c
// 统一AES加密接口（对外暴露，用户无需关注硬件/软件细节）
void cm32_aes_encrypt(uint8_t *key, uint8_t *iv, uint8_t *in, uint8_t *out, uint32_t len) {
  if (len % 16 != 0) return; // AES-CBC要求数据长度为16字节整数倍
  if (g_secure_mode) {
    sac_aes128_cbc_encrypt(key, iv, in, out, len); // 硬件加密
  } else {
    sw_aes128_cbc_encrypt(key, iv, in, out, len);  // 软件加密
  }
}
```


### 4. 系统集成与测试验证
#### 4.1 系统初始化流程（参考《CM32M433R-START生态开发板硬件手册V1.1.pdf》）
```c
int main(void) {
  // 1. 初始化基础外设
  uart_init(USART1, 115200); // UART调试（115200bps）
  key_init();                 // 切换按键初始化
  // 2. 测试数据准备（AES-128密钥、IV、测试数据）
  uint8_t aes_key[16] = {0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
                         0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10};
  uint8_t aes_iv[16]  = {0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,
                         0x88,0x99,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF};
  uint8_t test_in[32]  = "CM32M433R_AES_Test_Data";
  uint8_t test_out[32] = {0};
  // 3. 循环加密测试（按按键切换模式）
  while(1) {
    cm32_aes_encrypt(aes_key, aes_iv, test_in, test_out, 32); // 统一接口加密
    // 打印加密结果与速率（UART）
    uart_send_str(USART1, "Encrypt Done! Mode: ");
    uart_send_byte(USART1, g_secure_mode?'H':'S');
    uart_send_str(USART1, "\r\n");
    delay_ms(1000); // 1秒循环一次
  }
}
```

#### 4.2 测试验证指标（参考数据手册4.3.5章、用户手册16章）
| 测试项          | 硬件加密（SAC） | 软件加密（tiny-AES-c） | 文档依据                  |
|-----------------|-----------------|------------------------|---------------------------|
| 加密速率        | ≥110KB/s        | 10~15KB/s               | 数据手册4.3.5章“电流/速率” |
| 资源占用（ROM） | ≤2KB（SAC驱动） | ≤2KB（tiny-AES-c）      | 用户手册2.2.1章Flash特性  |
| 资源占用（SRAM）| ≤1KB（缓冲区）  | ≤1KB（缓冲区+库）       | 用户手册2.2.3章SRAM特性   |
| 切换响应延迟    | ≤1ms            | ≤1ms                   | 数据手册4.3.5章CPU时序    |


### 5. 关键注意事项（基于文档避坑）
1. **SAC时钟使能**：硬件加密前必须确认`RCC_AHBPCLKEN`的SACEN位=1（用户手册5.3.7章），否则SAC寄存器读写无响应；
2. **数据长度对齐**：AES-CBC模式要求数据长度为16字节整数倍，统一接口需增加长度校验，避免硬件/软件加密报错；
3. **密钥安全存储**：硬件加密密钥存于0x20001000（M模式只读），需配置PMP规则（用户手册2.2.1章），禁止U模式修改，防止密钥泄露；
4. **样例工程复用**：优先复用《CM32M433R_START_CAT1_01.pdf》中的SAC驱动和《CM32M4xxR开发板样例工程总体说明.pdf》中的tiny-AES-c移植代码，减少开发量。


## 三、结论：无需采购两块开发板
基于CM32M433R的硬件资源（独立SAC模块、充足SRAM/Flash）和软件可实现性（统一接口+模式切换逻辑），**单块开发板完全满足硬件/软件加密一键切换需求**，无需额外采购。实施方案已覆盖文档中的寄存器配置、外设驱动、样例工程复用，所有步骤均有官方文档支撑，可直接落地验证。