ä¸‹é¢ç»™å‡ºä¸‰éƒ¨åˆ†å†…å®¹ï¼š

1. å¯è¡Œæ€§åˆ†æä¸æ”¹è¿›å»ºè®®ï¼ˆå«å¯¹ç°æœ‰ä¸¤ä»½ä»£ç çš„â€œå‡ºå¤„æ ‡æ³¨â€ï¼‰ï¼›
2. æ–°çš„ç«¯åˆ°ç«¯å·¥ä½œæµç¨‹ï¼ˆåŠ /è§£å¯†è‡ªåŠ¨åŒ–ä¸1KBåˆ†å—ï¼‰ï¼›
3. ä¿®æ”¹åçš„å®Œæ•´ä»£ç ï¼šâ‘ Pythonï¼ˆåœ¨åŸè„šæœ¬åŸºç¡€ä¸Šæ–°å¢å‡½æ•°ä¸å…¥å£é€»è¾‘ï¼‰ï¼Œâ‘¡MCUå›ºä»¶ï¼ˆæ–°å¢â€œæµå¼åŠ /è§£å¯†â€æ¨¡å¼å¹¶ä¿ç•™åŸæœ‰æ¼”ç¤ºåŠŸèƒ½ï¼‰ã€‚

---

# ä¸€ã€å¯è¡Œæ€§åˆ†æï¼ˆæ˜¯å¦å¯å®ç°ï¼‰

**ç»“è®º**ï¼šå®Œå…¨å¯å®ç°ã€‚
åŸå› ï¼š

* **ä¸²å£é“¾è·¯å·²å…·å¤‡æ¡æ‰‹ä¸æ¨¡å¼é€‰æ‹©**ï¼šPython ä¸€ä¾§å·²åŒ…å«ç®€åŒ–æ¡æ‰‹ä¸è¿›å…¥æ–‡ä»¶æ¨¡å¼çš„é€»è¾‘ï¼›èƒ½æ£€æµ‹èœå•æ–‡æ¡ˆâ€œChoose mode / Optionsâ€å¹¶å‘é€`'f'`è¿›å…¥æ–‡ä»¶æ¨¡å¼ã€‚MCU ä¸€ä¾§å¯åŠ¨åæ‰“å°èœå•ï¼Œç­‰å¾…é€‰æ‹©å¹¶åœ¨æ”¶åˆ°`'f'`åè¿›å…¥â€œåŸºäºæ–‡ä»¶çš„ AES CBC æ¨¡å¼â€ã€‚
* **åŒæ–¹å·²å…·å¤‡å¸§å¤´/æ”¶å°¾ä¸æ”¶å‘ API**ï¼šPython å·²å‘é€`SIZE:len\n`ä¸`END\n`å¹¶é€å—å‘é€æ–‡ä»¶æ•°æ®ï¼›MCU ä¾§å·²æœ‰`read_file_data()`ä¸`write_file_data()`åšä¸²å£ç¼“å†²è¯»å†™ï¼Œä»¥åŠ`FILE_BUFFER_SIZE`å®ï¼ˆ1KBï¼‰ä½œä¸ºæ–‡ä»¶æµç¼“å†²åŒºå®¹é‡ã€‚
* **AES-CBC + PKCS#7 å·²å®Œå¤‡**ï¼šMCU å·²å®ç° PKCS#7 å¡«å……/å»å¡«å……ä¸ AES-CBC åŠ è§£å¯†ï¼ˆå«æ¼”ç¤ºä¸æ‰“å°ï¼‰ï¼Œå› æ­¤æ‰©å±•ä¸ºâ€œä»»æ„å¤§å°æ–‡ä»¶çš„åˆ†å—æµå¼å¤„ç†â€åªéœ€åœ¨ MCU ä¾§æ–°å¢ä¸€ä¸ªâ€œæµå¼æ¨¡å¼â€ï¼Œå¯¹æ¯ä¸ªåˆ†å—è¿›è¡Œ CBC ä¸²è”å¹¶åœ¨æœ€åä¸€å—æ‰§è¡Œ padding/unpadding å³å¯ã€‚
* **ä¼ è¾“ä¸­çš„äºŒè¿›åˆ¶å®‰å…¨æ€§**ï¼šMCU å·²æä¾›â€œBase64 å›é€åŠ å¯†å—â€çš„å·¥å…·å‡½æ•°`send_encrypted_data_base64()`ï¼Œå¯é¿å…æ—¥å¿—/æ§åˆ¶å°å¹²æ‰°äºŒè¿›åˆ¶æµã€‚å› æ­¤ï¼šåŠ å¯†è¿”å›ä½¿ç”¨ Base64 æ–‡æœ¬ï¼Œ`ciphertext.txt`å¤©ç„¶ä¸ºâ€œæ–‡æœ¬æ–‡ä»¶â€ï¼›è§£å¯†æ—¶ Python è¯»å– Base64 æ–‡æœ¬å¹¶åœ¨å‘é€å‰è§£ç ä¸ºäºŒè¿›åˆ¶ï¼ŒMCU å†åšè§£å¯†å¹¶å›ä¼ æ˜æ–‡ï¼ˆäºŒè¿›åˆ¶å¯ç›´æ¥å†™ output.txtï¼›è‹¥æ‹…å¿ƒæ§åˆ¶å°ä¸²æ‰°ï¼Œä¹Ÿå¯è®© MCU å›ä¼ æ˜æ–‡çš„ Base64â€”â€”æœ¬æ–‡ç»™å‡ºä¸¤ç§ä»»é€‰å…¶ä¸€çš„å®ç°ï¼Œé»˜è®¤å›ä¼ æ˜æ–‡ä¸º**åŸå§‹äºŒè¿›åˆ¶**ï¼Œæ•ˆç‡æ›´é«˜ï¼‰ã€‚

> ä»¥ä¸Šåˆ¤æ–­æ‰€ä¾æ®çš„å…·ä½“ä»£ç ä½ç½®ï¼š
>
> * Python ä¾§ï¼šæ¡æ‰‹ä¸èœå•æ¢æµ‹ã€è¿›å…¥`'f'`æ¨¡å¼ä¸`SIZE/END`åè®®ã€æŒ‰å—å‘é€ä¸è¿›åº¦è¾“å‡ºã€‚
> * MCU ä¾§ï¼š`FILE_BUFFER_SIZE`=1024 å®šä¹‰ã€ä¸²å£æ”¶å‘ã€èœå•/æ¨¡å¼åˆ‡æ¢ã€AES-CBCä¸PKCS#7å‡½æ•°ç°æˆå¯å¤ç”¨ã€‚

---

# äºŒã€å¯ä¼˜åŒ–/æ”¹è¿›ç‚¹

1. **å°†â€œæ–‡ä»¶æ¨¡å¼â€å‡çº§ä¸ºâ€œæµå¼åˆ†å—æ¨¡å¼â€ï¼ˆæ”¯æŒä»»æ„å¤§æ–‡ä»¶ï¼‰**

   * æ–°å¢ MCUâ€œæµå¼åŠ /è§£å¯†â€çŠ¶æ€æœºï¼šå¾ªç¯æ¥æ”¶å¤šå¸§ `SIZE:<n>\nLAST:<0|1>\n` + `<n bytes>` + `END\n`ï¼›
   * CBC æ¨¡å¼åœ¨**åŠ å¯†**æ—¶ï¼šæ¯å—ä½¿ç”¨â€œå‰ä¸€å—å¯†æ–‡â€ä½œä¸‹ä¸€å—çš„ IVï¼ˆç¬¬ä¸€å—ç”¨åˆå§‹ IVï¼‰ï¼›**è§£å¯†**æ—¶åŒç†ï¼›
   * **ä»…åœ¨æœ€åä¸€å—**æ‰§è¡Œ PKCS#7ï¼ˆåŠ å¯†æ—¶è¡¥é½ã€è§£å¯†æ—¶å»é™¤ï¼‰ã€‚

2. **Base64 çš„ç”¨æ³•ç»Ÿä¸€**

   * **åŠ å¯†æ–¹å‘**ï¼šMCU å›ä¼  Base64 æ–‡æœ¬ï¼ŒPython åŸæ ·å†™å…¥ `ciphertext.txt`ï¼ˆæ–‡æœ¬æ–‡ä»¶ï¼Œè·¨å¹³å°å®‰å…¨ï¼‰ã€‚
   * **è§£å¯†æ–¹å‘**ï¼šPython è¯»å– `ciphertext.txt` çš„ Base64 æ–‡æœ¬ã€åœ¨ PC ä¾§è§£ç ä¸ºäºŒè¿›åˆ¶ï¼Œå†æŒ‰ 1KB åˆ†å—å‘ç»™ MCU è§£å¯†ï¼ŒMCU å›ä¼ **åŸå§‹æ˜æ–‡äºŒè¿›åˆ¶**ï¼ˆæ•ˆç‡æœ€é«˜ï¼‰ï¼›å¦‚æœéœ€è¦â€œå…¨ç¨‹æ–‡æœ¬â€ï¼Œä¹Ÿå¯ä»¥æŠŠè§£å¯†å›ä¼ æ”¹æˆ Base64 æ–‡æœ¬ï¼Œå†ç”± Python è½ç›˜å‰è§£ç â€”â€”æœ¬æ–‡æä¾›å¯åˆ‡æ¢å¼€å…³ã€‚

3. **IV ä¸å®‰å…¨æ€§å»ºè®®**

   * å½“å‰ä»£ç ä½¿ç”¨å›ºå®š IVï¼ˆ1..16ï¼‰ï¼Œåœ¨åŠŸèƒ½éªŒè¯é˜¶æ®µå¯ç”¨ï¼Œä½†**ç”Ÿäº§å»ºè®®**ï¼šæ¯æ¬¡åŠ å¯†éšæœº IVï¼Œå¹¶å°† IV ä»¥ 16 å­—èŠ‚å‰ç¼€æˆ–å•ç‹¬å¤´éƒ¨å­˜å…¥ `ciphertext.txt`ï¼›Python è§£å¯†å‰è¯»å–è¯¥ IV å¹¶ä¼ ç»™ MCUã€‚æœ¬æ–‡é»˜è®¤ç»§ç»­æ²¿ç”¨ç°æœ‰å›ºå®š IVï¼Œé¿å…å¤§æ”¹ç°æœ‰ç»“æ„ã€‚

4. **åè®®å¥å£®æ€§**

   * æ–°å¤´å­—æ®µï¼š`LAST:0/1`ï¼ˆæ ‡è®°æ˜¯å¦æœ€åä¸€å—ï¼‰ï¼Œé¿å… MCU æ— æ³•åˆ¤æ–­ä½•æ—¶æ‰§è¡Œ padding/unpaddingï¼›
   * å›åŒ…æ ¼å¼ï¼šæ¯å—å›åŒ…å‰åŠ å½¢å¦‚ `OK <chunk_index> <out_len>\n` çš„ç¡®è®¤è¡Œï¼Œä¾¿äº Python ç²¾å‡†å†™å…¥ä¸è¿›åº¦ç»Ÿè®¡ã€‚

5. **å½»åº•å¯¹é½ 1KB å—å¤§å°**

   * Python ç«¯ä½¿ç”¨ `CHUNK_SIZE = 1024`ï¼Œä¸ MCU `FILE_BUFFER_SIZE` ä¿æŒä¸€è‡´ï¼Œæ»¡è¶³æ‚¨â€œæ¯æ¬¡ Python å‘ MCU ä¼ è¾“è‡³å¤š 1KBï¼ˆå®å®šä¹‰æ§åˆ¶ï¼‰â€çš„è¦æ±‚ã€‚

6. **ç«¯åˆ°ç«¯è‡ªåŠ¨åŒ–**

   * æ–°å¢ `run_encrypt_then_decrypt()`ï¼šè‡ªåŠ¨æ‰§è¡Œâ€œåŠ å¯†â†’å†™ciphertext.txtâ†’è§£å¯†â†’å†™output.txtâ†’å¯¹æ¯” input.txt å’Œ output.txtâ€ï¼Œå¹¶æ‰“å°â€œæˆåŠŸ/å¤±è´¥â€ã€‚

---

# ä¸‰ã€ç«¯åˆ°ç«¯æµç¨‹ï¼ˆè½åœ°ï¼‰

* **è¾“å…¥**ï¼š`input.txt`ï¼ˆä»»æ„å¤§å°ã€ä»»æ„å­—èŠ‚å†…å®¹ï¼‰
* **è¾“å‡º**ï¼š`ciphertext.txt`ï¼ˆBase64 æ–‡æœ¬ï¼‰ã€`output.txt`ï¼ˆäºŒè¿›åˆ¶ï¼Œä¸ input.txt ä¸€è‡´ï¼‰
* **å—å¤§å°**ï¼š1KBï¼ˆPython ç«¯å® `CHUNK_SIZE`ï¼ŒMCU ç«¯ `FILE_BUFFER_SIZE`ï¼‰
* **ä¸²å£é€Ÿç‡**ï¼š115200ï¼ˆæ²¿ç”¨ç°æœ‰ï¼‰
* **æµç¨‹**ï¼š

  1. Python æ‰“å¼€ä¸²å£â†’æ¡æ‰‹â†’è¿›å…¥æ–‡ä»¶æ¨¡å¼`'f'`ï¼›
  2. å‘é€å‘½ä»¤ `OP:ENC\nTOTAL:<filesize>\nGO\n`ï¼›
  3. é€å—å‘é€ï¼š`SIZE:<n>\nLAST:<0|1>\n` + `<nå­—èŠ‚>` + `END\n`ï¼›MCU å› `OK <idx> <outlen>\n` ä»¥åŠ `B64:<...>\n`ï¼ˆåŠ å¯†ç»“æœï¼‰ï¼›Python å°†å„å— Base64 é€è¡Œå†™å…¥ `ciphertext.txt`ï¼›
  4. å‘é€å‘½ä»¤ `OP:DEC\nTOTAL:<cipher_bytes>\nGO\n`ï¼›Python è¯»å– `ciphertext.txt`ã€Base64 è§£ç ååŒæ · 1KB åˆ†å—å‘é€ï¼›MCU å›**åŸå§‹æ˜æ–‡äºŒè¿›åˆ¶**ï¼›Python é€å—å†™å…¥ `output.txt`ï¼›
  5. Python æ¯”è¾ƒ `input.txt` ä¸ `output.txt` å­—èŠ‚çº§ä¸€è‡´æ€§ï¼Œæ‰“å°ç»“æœã€‚

---

# å››ã€ä¿®æ”¹åçš„ä»£ç 

> è¯´æ˜ï¼š
>
> * **Python**ï¼šåœ¨æ‚¨æä¾›çš„â€œSerial File Transport.py - æ”¹è¿›ç‰ˆæœ¬â€åŸºç¡€ä¸Šæ”¹é€ ã€‚ä¿ç•™åŸå‡½æ•°ï¼Œæ–°å¢ä¸€ç»„â€œæµå¼åŠ /è§£å¯†â€å‡½æ•°ä¸è‡ªåŠ¨åŒ–ä¸»æµç¨‹ï¼›é»˜è®¤ä¸²å£ç«¯å£ã€æ–‡ä»¶åæŒ‰æ‚¨çš„è¦æ±‚ï¼ˆ`input.txt` / `ciphertext.txt` / `output.txt`ï¼ŒåŒä¸€ç›®å½•ï¼‰ã€‚ç›¸å…³åŸå§‹ä¾æ®è¯·è§æ–‡å†…æ ‡æ³¨ã€‚
> * **MCU**ï¼šåœ¨æ‚¨æä¾›çš„ä¸»ç¨‹åºä¸­**æ–°å¢**â€œæµå¼æ¨¡å¼â€å®ç°ï¼ˆä¸ç ´ååŸæœ‰`interactive`/`file demo`ï¼‰ï¼›èœå•ä»æŒ‰åŸæ ·ï¼Œé€‰æ‹©`'f'`åè¿›å…¥å¢å¼ºæ–‡ä»¶æ¨¡å¼å¹¶å¯ç”¨æ–°çš„åˆ†å—åè®®ã€‚ç›¸å…³åŸå§‹ä¾æ®è¯·è§æ–‡å†…æ ‡æ³¨ã€‚

---

## 4.1 Pythonï¼ˆä¿®æ”¹ç‰ˆï¼‰

> å…³é”®ç‚¹ï¼š
>
> * `CHUNK_SIZE = 1024`
> * `op_encrypt()`å‘é€æ˜æ–‡å—ï¼Œæ¥æ”¶ Base64 è¡Œå†™å…¥ `ciphertext.txt`ï¼›
> * `op_decrypt()`è¯»å– `ciphertext.txt` çš„ Base64ï¼Œè§£ç åå‘é€ï¼Œæ¥æ”¶æ˜æ–‡å—å†™å…¥ `output.txt`ï¼›
> * `run_encrypt_then_decrypt()`è‡ªåŠ¨å®Œæˆå…¨æµç¨‹ä¸å¯¹æ¯”ã€‚
> * å…¼å®¹ç°æœ‰æ¡æ‰‹/èœå•/æ¨¡å¼æ¢æµ‹é€»è¾‘ã€‚

```python
# -*- coding: utf-8 -*-
# File: Serial File Transport (stream AES) - merged version

import serial
import time
import os
import base64
import sys

# ========== å¯è°ƒå‚æ•° ==========
PORT = "COM3"
BAUD = 115200
CHUNK_SIZE = 1024  # ä¸MCUä¾§FILE_BUFFER_SIZEä¿æŒä¸€è‡´

INPUT_FILE = "input.txt"
CIPHERTEXT_FILE = "ciphertext.txt"  # Base64 æ–‡æœ¬
OUTPUT_FILE = "output.txt"

# ========== å¤ç”¨æ‚¨ç°æœ‰çš„æ¡æ‰‹/æ¨¡å¼æ£€æµ‹é€»è¾‘ï¼ˆä¿ç•™å¹¶è½»é‡è°ƒæ•´ï¼‰ ==========
def simple_mcu_handshake(ser, timeout=5):
    """ç®€åŒ–çš„MCUæ¡æ‰‹åè®®ï¼ˆä¿ç•™åŸå®ç°ï¼‰"""
    print("ğŸ”„ Performing simple handshake with MCU...")
    start_time = time.time()

    ser.reset_input_buffer()
    ser.reset_output_buffer()
    time.sleep(0.5)

    # å‘é€ä»»æ„å­—èŠ‚è§¦å‘ READY
    ser.write(b'?')
    time.sleep(0.2)

    # ç­‰å¾…èœå•æˆ–æç¤º
    buf = b""
    while time.time() - start_time < timeout:
        if ser.in_waiting > 0:
            buf += ser.read(ser.in_waiting)
            txt = buf.decode('utf-8', errors='ignore')
            if 'READY' in txt:
                print("âœ… MCU READY")
                break
            if 'Choose mode' in txt or 'Options' in txt:
                print("âœ… MCU menu detected")
                break
        time.sleep(0.05)

    return True

def wait_for_menu_and_enter_file_mode(ser):
    """ç­‰å¾…èœå•å¹¶è¿›å…¥å¢å¼ºæ–‡ä»¶æ¨¡å¼ï¼ˆæŒ‰'f'ï¼‰ï¼Œå…¼å®¹åŸç‰ˆè¾“å‡ºå…³é”®å­—"""
    # æ¸…å±è¯»
    time.sleep(0.2)
    if ser.in_waiting:
        ser.read(ser.in_waiting)

    # å‘é€ 'f'
    print("ğŸ“¤ Selecting file mode ('f')...")
    ser.write(b'f')
    ser.flush()
    time.sleep(0.3)

    # ç­‰å¾…è¿›å…¥æ–‡ä»¶æ¨¡å¼æç¤ºï¼ˆä¸åŸæ–‡æ¡ˆå…¼å®¹ï¼‰
    start = time.time()
    buf = b""
    while time.time() - start < 5:
        if ser.in_waiting:
            buf += ser.read(ser.in_waiting)
            txt = buf.decode('utf-8', errors='ignore')
            if ('File-based AES CBC' in txt or
                'ENHANCED AES CBC' in txt or
                'Ready to receive file data' in txt or
                'Processor' in txt):
                print("âœ… MCU entered file mode")
                return True
        time.sleep(0.05)

    print("âš ï¸ file mode detection timed out (continuing anyway)")
    return True

# ========== æ–°å¢ï¼šåŸºäºåˆ†å—çš„æµå¼åè®®å·¥å…· ==========
def _send_line(ser, s):
    ser.write(s.encode('utf-8'))
    ser.flush()

def _read_line(ser, timeout=5):
    start = time.time()
    buf = bytearray()
    while time.time() - start < timeout:
        if ser.in_waiting:
            ch = ser.read(1)
            if ch == b'\n':
                return buf.decode('utf-8', errors='ignore').rstrip('\r')
            else:
                buf.extend(ch)
        else:
            time.sleep(0.01)
    return None

def _expect_ok_header(ser, chunk_idx, timeout=5):
    """æœŸæœ›æ”¶åˆ° 'OK <idx> <outlen>' ç¡®è®¤è¡Œ"""
    line = _read_line(ser, timeout=timeout)
    if not line:
        raise RuntimeError("Timeout waiting OK header")
    if not line.startswith("OK "):
        raise RuntimeError(f"Unexpected header: {line!r}")
    parts = line.split()
    if len(parts) < 3:
        raise RuntimeError(f"Malformed OK line: {line!r}")
    if int(parts[1]) != chunk_idx:
        raise RuntimeError(f"Chunk index mismatch: expect {chunk_idx}, got {parts[1]}")
    outlen = int(parts[2])
    return outlen

# ========== æ–°å¢ï¼šæ“ä½œ - åŠ å¯† ==========
def op_encrypt(ser, in_path, out_path):
    filesize = os.path.getsize(in_path)
    print(f"ğŸ” Encrypting {in_path} -> {out_path}  (size={filesize} bytes)")

    # å‘é€æ“ä½œå¤´
    _send_line(ser, f"OP:ENC\n")
    _send_line(ser, f"TOTAL:{filesize}\n")
    _send_line(ser, f"GO\n")

    sent = 0
    chunk_idx = 0
    with open(in_path, 'rb') as fin, open(out_path, 'w', encoding='utf-8') as fout:
        while True:
            chunk = fin.read(CHUNK_SIZE)
            if not chunk:
                # å‘é€ç»“æŸå—ï¼ˆSIZE:0, LAST:1ï¼‰
                _send_line(ser, "SIZE:0\n")
                _send_line(ser, "LAST:1\n")
                _send_line(ser, "END\n")
                break

            chunk_idx += 1
            last = 1 if (sent + len(chunk) == filesize) else 0

            _send_line(ser, f"SIZE:{len(chunk)}\n")
            _send_line(ser, f"LAST:{last}\n")
            ser.write(chunk)              # åŸå§‹æ˜æ–‡æ•°æ®
            ser.flush()
            _send_line(ser, "END\n")

            # ç­‰å¾… OK ä¸ Base64 è¡Œï¼ˆMCU å›åŒ… Base64ï¼‰
            outlen = _expect_ok_header(ser, chunk_idx, timeout=10)
            b64line = _read_line(ser, timeout=10)
            if not b64line or not b64line.startswith("B64:"):
                raise RuntimeError(f"Expect B64 line, got: {b64line!r}")

            # å†™å…¥ Base64 æ–‡æœ¬ï¼ˆä¸å«å‰ç¼€ï¼‰ï¼Œä¸€è¡Œä¸€å—ï¼Œå¹²å‡€æ˜“ç”¨
            b64data = b64line[4:]
            fout.write(b64data + "\n")

            sent += len(chunk)
            print(f"ğŸ“¤ ENC progress: {sent}/{filesize} bytes ({sent*100//filesize}%)")

    print("âœ… Encryption done, ciphertext saved as Base64 text.")


# ========== æ–°å¢ï¼šæ“ä½œ - è§£å¯† ==========
RETURN_PLAINTEXT_AS_BASE64 = False  # å¦‚éœ€MCUä»¥Base64å›ä¼ æ˜æ–‡ï¼Œå¯ç½® True

def op_decrypt(ser, in_path, out_path):
    # è¯»å– Base64 æ–‡æœ¬å¹¶æ‹¼ä¸º bytesï¼ˆPython ä¾§å…ˆè§£ç ï¼Œå†å‘é€äºŒè¿›åˆ¶ç»™MCUï¼‰
    print(f"ğŸ”“ Decrypting {in_path} -> {out_path}")
    b64_total_lines = 0
    cipher_bytes = bytearray()
    with open(in_path, 'r', encoding='utf-8') as f:
        for line in f:
            s = line.strip()
            if not s:
                continue
            b64_total_lines += 1
            cipher_bytes.extend(base64.b64decode(s))

    total = len(cipher_bytes)
    print(f"ğŸ”¢ Decoded ciphertext bytes: {total}")

    # å‘æ“ä½œå¤´
    _send_line(ser, f"OP:DEC\n")
    _send_line(ser, f"TOTAL:{total}\n")
    _send_line(ser, f"GO\n")
    _send_line(ser, f"MODE:{'B64' if RETURN_PLAINTEXT_AS_BASE64 else 'BIN'}\n")

    sent = 0
    chunk_idx = 0
    with open(out_path, 'wb') as fout:
        pos = 0
        while pos < total:
            n = min(CHUNK_SIZE, total - pos)
            chunk = cipher_bytes[pos:pos+n]
            pos += n

            last = 1 if pos == total else 0
            chunk_idx += 1

            _send_line(ser, f"SIZE:{len(chunk)}\n")
            _send_line(ser, f"LAST:{last}\n")
            ser.write(chunk)
            ser.flush()
            _send_line(ser, "END\n")

            # ç­‰å¾… OK ä¸æ•°æ®è¡Œ
            outlen = _expect_ok_header(ser, chunk_idx, timeout=10)

            if RETURN_PLAINTEXT_AS_BASE64:
                line = _read_line(ser, timeout=10)
                if not line or not line.startswith("B64:"):
                    raise RuntimeError(f"Expect B64 line, got: {line!r}")
                data = base64.b64decode(line[4:])
            else:
                # ç›´æ¥è¯»å–äºŒè¿›åˆ¶ outlen å­—èŠ‚
                buf = bytearray()
                start = time.time()
                while len(buf) < outlen and time.time() - start < 10:
                    if ser.in_waiting:
                        buf.extend(ser.read(min(outlen - len(buf), ser.in_waiting)))
                    else:
                        time.sleep(0.005)
                if len(buf) != outlen:
                    raise RuntimeError(f"Binary read timeout: want {outlen}, got {len(buf)}")
                data = bytes(buf)

            fout.write(data)
            sent += n
            print(f"ğŸ“¥ DEC progress: {sent}/{total} bytes ({sent*100//total}%)")

    print("âœ… Decryption done, plaintext saved.")

# ========== æ–°å¢ï¼šè‡ªåŠ¨åŒ–ä¸»æµç¨‹ ==========
def run_encrypt_then_decrypt():
    if not os.path.exists(INPUT_FILE):
        print(f"âŒ Missing {INPUT_FILE}")
        sys.exit(1)

    with serial.Serial(PORT, BAUD, timeout=1) as ser:
        print(f"âœ… Serial opened {PORT}@{BAUD}")
        simple_mcu_handshake(ser)  #
        wait_for_menu_and_enter_file_mode(ser)  #

        # è¿›å…¥å¢å¼ºæµå¼æ¨¡å¼åï¼Œæ‰§è¡ŒåŠ å¯†ä¸è§£å¯†
        op_encrypt(ser, INPUT_FILE, CIPHERTEXT_FILE)
        time.sleep(0.2)
        op_decrypt(ser, CIPHERTEXT_FILE, OUTPUT_FILE)

    # å¯¹æ¯” input.txt ä¸ output.txt
    same = False
    with open(INPUT_FILE, 'rb') as f1, open(OUTPUT_FILE, 'rb') as f2:
        same = (f1.read() == f2.read())

    if same:
        print("ğŸ‰ SUCCESS: input.txt == output.txt")
    else:
        print("âŒ MISMATCH: input.txt != output.txt")

if __name__ == "__main__":
    run_encrypt_then_decrypt()
```

> å…³é”®ä½ç½®çš„æ¥æºè¯´æ˜ï¼š
>
> * æ¡æ‰‹/èœå•æ¢æµ‹ä¸`'f'`é€‰æ‹©ã€æ£€æŸ¥å…³é”®æç¤ºæ–‡æ¡ˆï¼Œå‡ä¸æ‚¨åŸè„šæœ¬çš„å¤„ç†ä¿æŒä¸€è‡´ä¸å…¼å®¹ã€‚
> * 1KB åˆ†å—ä¸å®ä¸€è‡´æ€§ï¼ˆ`CHUNK_SIZE=1024`ï¼‰å¯¹é½ MCU ç«¯ `FILE_BUFFER_SIZE`ã€‚

---

## 4.2 MCU å›ºä»¶ï¼ˆåœ¨åŸæ–‡ä»¶ä¸Šæ–°å¢â€œæµå¼åˆ†å—æ¨¡å¼â€ï¼‰

> è¯´æ˜ï¼š
>
> * ä¿ç•™åŸæœ‰ `aes_cbc_interactive()`ã€`process_file_aes_cbc()` ç­‰æ¼”ç¤ºï¼›
> * æ–°å¢ `process_stream_aes_cbc()`ï¼šå®ç°çœŸæ­£çš„**ä»»æ„å¤§å°**æ–‡ä»¶åŠ /è§£å¯†ï¼›
> * ä¸»èœå•é€‰é¡¹ `'f'` æ—¶ï¼Œæ”¹ä¸ºè°ƒç”¨ `process_stream_aes_cbc()`ï¼›
> * ä»æ²¿ç”¨å›ºå®š Key/IVï¼ˆä¾¿äºå¤ç”¨ç°æœ‰é€»è¾‘ï¼‰ï¼›å¦‚éœ€æ›´å®‰å…¨ï¼Œå¯æ‰©å±•æˆéšæœº IV å¹¶åœ¨å¤´éƒ¨ä¼ è¾“/ä¿å­˜ã€‚
> * å¤ç”¨ç°æœ‰çš„ `pkcs7_padding()` / `pkcs7_unpadding()`ã€`read_file_data()` / `write_file_data()`ã€`DumpBytes()` ç­‰å‡½æ•°ã€‚

> **æ–°å¢/ä¿®æ”¹ç‰‡æ®µ**ï¼ˆå°†ä¸‹è¿°ç‰‡æ®µåˆå…¥æ‚¨æä¾›çš„ MCU æºæ–‡ä»¶ä¸­ç›¸åº”ä½ç½®å³å¯ï¼‰ï¼š

```c
// ===== åœ¨æ–‡ä»¶é¡¶éƒ¨çš„ include/å® ä¹‹åï¼Œæ²¿ç”¨æ‚¨ç°æœ‰å®šä¹‰ =====
// FILE_BUFFER_SIZE å·²ä¸º 1024 
// AES_BLOCK_SIZE å·²ä¸º 16   
// å¤ç”¨ pkcs7_padding / pkcs7_unpadding / read_file_data / write_file_data ç­‰

// ===== æ–°å¢ï¼šä»ä¸²å£è¯»å–ä¸€è¡Œï¼ˆä»¥ '\n' ç»“å°¾ï¼‰ï¼Œè¿”å›é•¿åº¦ï¼ˆä¸å«ç»“å°¾æ¢è¡Œï¼‰ï¼Œè¶…æ—¶è¿”å›0 =====
static uint32_t uart_read_line(char *line, uint32_t maxlen, uint32_t wait_loops) {
    uint32_t len = 0, loops = 0;
    while (loops < wait_loops) {
        if (USART_GetFlagStatus(USARTx, USART_FLAG_RXDNE) != RESET) {
            int ch = USART_ReceiveData(USARTx);
            if (ch == '\n' || ch == '\r') {
                line[len] = 0;
                return len;
            }
            if (len + 1 < maxlen) line[len++] = (char)ch;
        } else {
            // ç®€å•ç­‰å¾…
            for (volatile int i = 0; i < 2000; i++);
            loops++;
        }
    }
    return 0;
}

// ===== æ–°å¢ï¼šè¯»å–ä¸€å¸§æ•°æ®ä½“ï¼ˆSIZE:n + LAST:x + <n bytes> + ENDï¼‰=====
static int uart_read_frame(uint8_t *buf, uint32_t bufcap, uint32_t *size_out, int *is_last) {
    char line[64];
    uint32_t n = 0;
    *size_out = 0; *is_last = 0;

    // è¯» SIZE è¡Œ
    if (uart_read_line(line, sizeof(line), 30000) == 0) return -1;
    if (strncmp(line, "SIZE:", 5) != 0) return -2;
    n = (uint32_t)atoi(line + 5);
    if (n > bufcap) return -3;

    // è¯» LAST è¡Œ
    if (uart_read_line(line, sizeof(line), 10000) == 0) return -4;
    if (strncmp(line, "LAST:", 5) != 0) return -5;
    *is_last = atoi(line + 5) ? 1 : 0;

    // è¯»æ•°æ®ä½“ n å­—èŠ‚
    uint32_t rcv = 0;
    while (rcv < n) {
        if (USART_GetFlagStatus(USARTx, USART_FLAG_RXDNE) != RESET) {
            buf[rcv++] = USART_ReceiveData(USARTx);
        }
    }

    // è¯» END
    if (uart_read_line(line, sizeof(line), 10000) == 0) return -6;
    if (strcmp(line, "END") != 0) return -7;

    *size_out = n;
    return 0;
}

// ===== æ–°å¢ï¼šBase64 ç¼–ç ï¼ˆæœ€å°åŒ–å®ç°ï¼Œå¤ç”¨æ‚¨ç°æœ‰ send_encrypted_data_base64 é€»è¾‘äº¦å¯ï¼‰=====
static const char b64_tab[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

static void b64_encode_block(const uint8_t *in, uint32_t len, char *out) {
    uint32_t triple = 0;
    triple |= (len > 0 ? in[0] << 16 : 0);
    triple |= (len > 1 ? in[1] << 8 : 0);
    triple |= (len > 2 ? in[2] : 0);
    out[0] = b64_tab[(triple >> 18) & 0x3F];
    out[1] = b64_tab[(triple >> 12) & 0x3F];
    out[2] = (len > 1) ? b64_tab[(triple >> 6) & 0x3F] : '=';
    out[3] = (len > 2) ? b64_tab[triple & 0x3F] : '=';
}

static uint32_t b64_encode(const uint8_t *in, uint32_t inlen, char *out) {
    uint32_t i=0, j=0;
    while (i < inlen) {
        uint32_t rem = inlen - i;
        uint32_t n = rem >= 3 ? 3 : rem;
        b64_encode_block(in + i, n, out + j);
        i += n; j += 4;
    }
    out[j] = 0;
    return j;
}

// ===== æ–°å¢ï¼šæµå¼ AES-CBC å¤„ç† =====
static void process_stream_aes_cbc(void) {
    set_system_state(STATE_FILE_MODE_READY);  //
    printf("âœ… Enhanced Stream AES-CBC Mode Ready\n");
    fflush_output();

    __attribute__ ((aligned (4))) uint8_t key[16] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
    __attribute__ ((aligned (4))) uint8_t iv0[16]  = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};

    AES_PARM AES_Parm = {0};
    uint8_t  iv_curr[16];
    uint8_t  inbuf[FILE_BUFFER_SIZE];     // 1KB è¾“å…¥ç¼“å†²
    uint8_t  work[AES_BLOCK_SIZE];
    uint8_t  outblock[AES_BLOCK_SIZE];
    char     line[64];

    // è¯»å–æ“ä½œå¤´
    if (uart_read_line(line, sizeof(line), 30000) == 0) return; // OP:ENC æˆ– OP:DEC
    int do_encrypt = 0;
    if (strcmp(line, "OP:ENC") == 0) do_encrypt = 1;
    else if (strcmp(line, "OP:DEC") == 0) do_encrypt = 0;
    else return;

    // æ€»é•¿åº¦ï¼ˆä»…ä½œæ˜¾ç¤ºç”¨é€”ï¼‰
    uint32_t total = 0;
    if (uart_read_line(line, sizeof(line), 10000) == 0) return; // TOTAL:xxxx
    if (strncmp(line, "TOTAL:", 6) == 0) total = (uint32_t)atoi(line + 6);

    // å¯é€‰æ¨¡å¼ï¼ˆè§£å¯†å›ä¼ BINæˆ–B64ï¼‰
    int ret_b64 = 0; // é»˜è®¤äºŒè¿›åˆ¶å›ä¼ 
    if (!do_encrypt) {
        if (uart_read_line(line, sizeof(line), 10000) == 0) return; // å¯èƒ½æ˜¯ GO æˆ– MODE
        if (strncmp(line, "MODE:", 5) == 0) {
            ret_b64 = (strcmp(line + 5, "B64") == 0);
            // ç»§ç»­è¯» GO
            if (uart_read_line(line, sizeof(line), 10000) == 0) return;
        }
    }

    // should be "GO"
    if (strcmp(line, "GO") != 0) return;

    memcpy(iv_curr, iv0, 16);

    uint32_t processed = 0;
    uint32_t chunk_idx = 0;

    while (1) {
        uint32_t n = 0;
        int is_last = 0;
        if (uart_read_frame(inbuf, sizeof(inbuf), &n, &is_last) != 0) {
            printf("âŒ frame read error\n");
            fflush_output();
            break;
        }
        if (n == 0 && is_last) {
            // ç»“æŸ
            break;
        }

        chunk_idx++;

        // å—å†…ä»¥ AES_BLOCK_SIZE å¤„ç†
        uint32_t pos = 0;
        uint32_t out_bytes_this_chunk = 0;

        // è®¡ç®— padding æƒ…å†µï¼ˆä»…å¯¹æœ€åä¸€å¸§çš„æœ€åä¸€å—åšï¼‰
        uint8_t last_block_buf[AES_BLOCK_SIZE];
        uint32_t tail = (n % AES_BLOCK_SIZE);
        int need_pad = (do_encrypt && is_last && (tail != 0));
        int full_blocks = (int)(n / AES_BLOCK_SIZE);

        // å‘é€ OK å¤´ï¼Œå…ˆä¿ç•™ç©ºé—´ç»Ÿè®¡è¾“å‡ºé•¿åº¦
        // å¯¹äº ENCï¼šè¾“å‡ºé•¿åº¦ = full_blocks*16 + (need_pad?16:(tail?16:0))
        // å¯¹äº DECï¼šè¾“å‡ºé•¿åº¦ = full_blocks*16 (+å¯èƒ½åŒ…å« 16*(tail!=0) )ï¼Œä½†å®é™…æœ€åä¸€å¸§å» padding åæ‰çŸ¥é“æœ€ç»ˆé•¿åº¦ã€‚
        // ä¸ºç®€åŒ–ï¼šæˆ‘ä»¬é€ block å‘é€/ç´¯ç§¯ï¼Œå†åœ¨åŒä¸€å¸§å†…æ±‡æ€»é•¿åº¦ã€‚
        // è¿™é‡Œå…ˆè®¡ç®—ä¸€ä¸ªâ€œä¼°è®¡é•¿åº¦â€ï¼Œéšåä¸¥æ ¼æŒ‰çœŸå®é•¿åº¦å‘é€æ•°æ®ã€‚
        // æˆ‘ä»¬é€‰æ‹©ï¼šå…ˆä¸ç«‹å³å‘ OKï¼›ç­‰ç®—å‡ºæ•´å¸§è¾“å‡ºå­—èŠ‚æ•°åå†å‘ã€‚

        // ===== å…ˆæŠŠè¾“å‡ºç¼“å­˜åˆ°ä¸€æ¡ Base64 è¡Œæˆ–ç›´æ¥äºŒè¿›åˆ¶é€ block å‘é€ =====
        // æ–¹æ¡ˆï¼šä¸ºäº†åè®®ä¸€è‡´æ€§ï¼Œæ¯å¸§å‘é€ä¸€æ¡ B64 æˆ–ä¸€æ®µ BINã€‚
        uint8_t outbin[FILE_BUFFER_SIZE + AES_BLOCK_SIZE]; // è¶³å¤Ÿå®¹çº³å¤šä¸€ä¸ªpaddingå—
        uint32_t outpos = 0;

        // å¤„ç†å®Œæ•´ blocks
        for (int b = 0; b < full_blocks; ++b) {
            memcpy(work, inbuf + pos, AES_BLOCK_SIZE);
            pos += AES_BLOCK_SIZE;

            AES_Parm.in = (uint32_t*)work;
            AES_Parm.out = (uint32_t*)outblock;
            AES_Parm.key = (uint32_t*)key;
            AES_Parm.iv  = (uint32_t*)iv_curr;
            AES_Parm.inWordLen = AES_BLOCK_SIZE/4;
            AES_Parm.keyWordLen = sizeof(key)/4;
            AES_Parm.Mode = AES_CBC;
            AES_Parm.En_De = do_encrypt ? AES_ENC : AES_DEC;

            if (AES_Init_OK != AES_Init(&AES_Parm)) { printf("âŒ AES_Init\n"); break; }
            if (AES_Crypto_OK != AES_Crypto(&AES_Parm)) { AES_Close(); printf("âŒ AES_Crypto\n"); break; }
            AES_Close();

            // CBC ä¸²è”ï¼šæ›´æ–° iv
            memcpy(iv_curr, outblock, AES_BLOCK_SIZE);

            // è¿½åŠ åˆ°è¾“å‡ºç¼“å­˜
            memcpy(outbin + outpos, outblock, AES_BLOCK_SIZE);
            outpos += AES_BLOCK_SIZE;
        }

        // å¤„ç†æœ€åä¸è¶³ 16 å­—èŠ‚çš„éƒ¨åˆ†
        if (tail) {
            if (do_encrypt) {
                // åŠ å¯†ï¼šåªæœ‰æœ€åä¸€å¸§æ‰å…è®¸ä¸è¶³å—ï¼Œéœ€ padding
                memcpy(last_block_buf, inbuf + pos, tail);
                if (is_last) {
                    uint32_t padded_len = AES_BLOCK_SIZE;
                    pkcs7_padding(last_block_buf, &padded_len, AES_BLOCK_SIZE); //
                } else {
                    // ä¸­é—´å¸§ä¸åº”å‡ºç°é 16 å¯¹é½
                    // ç®€å•å®¹é”™ï¼šæŒ‰ 16 è¡¥ 0ï¼ˆä¹Ÿå¯ç›´æ¥æŠ¥é”™ï¼‰
                    for (uint32_t i = tail; i < AES_BLOCK_SIZE; ++i) last_block_buf[i] = (uint8_t)(AES_BLOCK_SIZE - tail);
                }

                AES_Parm.in = (uint32_t*)last_block_buf;
                AES_Parm.out = (uint32_t*)outblock;
                AES_Parm.key = (uint32_t*)key;
                AES_Parm.iv  = (uint32_t*)iv_curr;
                AES_Parm.inWordLen = AES_BLOCK_SIZE/4;
                AES_Parm.keyWordLen = sizeof(key)/4;
                AES_Parm.Mode = AES_CBC;
                AES_Parm.En_De = AES_ENC;

                if (AES_Init_OK == AES_Init(&AES_Parm) && AES_Crypto_OK == AES_Crypto(&AES_Parm)) {
                    AES_Close();
                    memcpy(iv_curr, outblock, AES_BLOCK_SIZE);
                    memcpy(outbin + outpos, outblock, AES_BLOCK_SIZE);
                    outpos += AES_BLOCK_SIZE;
                } else {
                    AES_Close();
                    printf("âŒ AES tail enc\n");
                }
            } else {
                // è§£å¯†ï¼šä¸­é—´å¸§å°¾éƒ¨åº”è¯¥ä¹Ÿæ˜¯ 16 å¯¹é½ï¼›è‹¥ä¸æ˜¯ï¼Œç›´æ¥æŒ‰å—å¯¹é½å¤„ç†ï¼ˆå¸¸è§„ CBC å¯†æ–‡åº”æ€»æ˜¯ 16 çš„å€æ•°ï¼‰
                // è¿™é‡Œå‡è®¾è¾“å…¥å¯†æ–‡æ€»æ˜¯ 16 å¯¹é½ï¼›è‹¥ä¸æ˜¯ï¼Œå¯ç¼“å†²åˆ°ä¸‹ä¸€å¸§å†è¡¥é½ã€‚
                // ä¸ºç®€å•èµ·è§ï¼Œè¦æ±‚ä¸Šä½æœºï¼ˆPythonï¼‰æŒ‰ 1KB åˆ†å—ã€ä¸”å¯†æ–‡æŒ‰ 16 å¯¹é½åˆ†å¸§ï¼ˆç”±æˆ‘ä»¬åœ¨ Python ä¾§ä¿è¯ï¼‰ã€‚
            }
        } else if (do_encrypt && is_last && full_blocks == 0) {
            // ç‰¹æ®Šï¼šæœ€åä¸€å¸§ä¸” n==0 çš„æƒ…å†µï¼Œä¸éœ€è¦åšä»»ä½•äº‹ï¼ˆåŠ å¯†ç©ºå¸§ï¼‰
        }

        // è§£å¯†çš„æœ€åä¸€å¸§ï¼šéœ€è¦å» padding
        if (!do_encrypt && is_last && outpos >= AES_BLOCK_SIZE) {
            uint32_t ulen = outpos;
            if (pkcs7_unpadding(outbin, &ulen) == 0) { //
                outpos = ulen;
            } else {
                // unpadding å¤±è´¥ï¼Œä¿æŒåŸæ ·ï¼ˆä¹Ÿå¯è¿”å›é”™è¯¯ï¼‰
            }
        }

        // ç°åœ¨å¯ä»¥å‘ OK å¤´å’Œæ•°æ®ä½“
        printf("OK %lu %lu\n", (unsigned long)chunk_idx, (unsigned long)outpos);
        fflush_output();

        if (do_encrypt) {
            // å› Base64 æ–‡æœ¬ï¼ˆå•è¡Œï¼‰
            char *b64 = (char*)malloc(outpos * 4 / 3 + 8);
            uint32_t b64len = b64_encode(outbin, outpos, b64);
            printf("B64:%s\n", b64);
            fflush_output();
            free(b64);
        } else {
            if (ret_b64) {
                char *b64 = (char*)malloc(outpos * 4 / 3 + 8);
                uint32_t b64len = b64_encode(outbin, outpos, b64);
                printf("B64:%s\n", b64);
                fflush_output();
                free(b64);
            } else {
                // ç›´æ¥å›äºŒè¿›åˆ¶
                write_file_data(outbin, outpos); //
            }
        }

        processed += n;
    }

    printf("ğŸ¯ Stream AES done. processed=%lu bytes (in)\n", (unsigned long)processed);
    fflush_output();
}

// ===== åœ¨ main() çš„ 'f' åˆ†æ”¯ä¸­ï¼Œæ›¿æ¢ä¸ºè°ƒç”¨æ–°æµå¼å¤„ç† =====
/*
case 'f':
case 'F':
    printf("ğŸ”§ Starting File-based AES CBC Mode...\n");
    set_system_state(STATE_FILE_MODE_READY);
    printf("âœ… Ready to receive file data\n");
    printf("ğŸ“¥ Waiting for file transmission...\n");
    fflush_output();
    for(volatile int i = 0; i < 500000; i++);
    process_file_aes_cbc(); // æ—§å®ç°
    break;
*/
```

å°†ä¸Šé¢ `case 'f'/'F'` æ›¿æ¢ä¸ºï¼š

```c
case 'f':
case 'F':
    printf("ğŸ”§ Starting Enhanced Stream File Mode...\n");
    fflush_output();
    process_stream_aes_cbc();   // æ–°çš„æµå¼ä»»æ„å¤§å°å®ç°
    break;
```

> ä»¥ä¸Š MCU å˜æ›´å‡å»ºç«‹åœ¨æ‚¨ç°æœ‰å‡½æ•°/å®/ä¸²å£ä¸ AES å·¥å…·çš„åŸºç¡€ä¹‹ä¸Šã€‚

---

# äº”ã€ç«¯åˆ°ç«¯è‡ªæ£€ä¸æœŸæœ›ç°è±¡

1. æŠŠéœ€è¦åŠ å¯†çš„åŸå§‹æ–‡ä»¶å‘½åä¸º `input.txt` æ”¾åœ¨ Python è„šæœ¬åŒç›®å½•ã€‚
2. è¿è¡Œ Python è„šæœ¬ï¼šå®ƒä¼šè‡ªåŠ¨ä¸²å£æ¡æ‰‹â†’è¿›å…¥æ–‡ä»¶æ¨¡å¼â†’åŠ å¯†â†’å†™ `ciphertext.txt`ï¼ˆBase64 æ–‡æœ¬ï¼Œä¸€è¡Œä¸€å—ï¼‰â†’å†è§£å¯†â†’å†™ `output.txt`ã€‚
3. æ§åˆ¶å°è¾“å‡º `ğŸ‰ SUCCESS: input.txt == output.txt` è¡¨ç¤ºåŠ /è§£å¯†é—­ç¯æ­£ç¡®ã€‚
4. è‹¥ `ciphertext.txt` è¢«å¤åˆ¶åˆ°å…¶å®ƒç¯å¢ƒï¼Œåªè¦æŠŠæ¯è¡Œ Base64 æ‹¼æ¥/è§£ç å³å¯è¿˜åŸå¯†æ–‡å­—èŠ‚æµï¼ˆå»ºè®®åœ¨ç”Ÿäº§ä¸­å­˜å‚¨â€œIV å‰ç¼€ + å¯†æ–‡â€ï¼‰ã€‚

---

# å…­ã€ä¸åŸå§‹ä»£ç çš„å¯¹åº”å…³ç³»ï¼ˆå¼•ç”¨ï¼‰

* **Python**ï¼š

  * èœå•/æ¨¡å¼æ¢æµ‹ä¸ `'f'` é€‰æ‹©æ²¿ç”¨åŸé€»è¾‘ä¸å…³é”®å­—åŒ¹é…ï¼›
  * åŸåè®®å¤´ `SIZE:...`ã€`END` çš„æ€æƒ³è¢«æ‰©å±•ä¸º**å¤šå¸§å¾ªç¯**å¹¶æ–°å¢ `LAST:` æ ‡è®°ã€‚

* **MCU**ï¼š

  * `FILE_BUFFER_SIZE` å®šä¹‰ä¸º 1024ï¼Œä¸éœ€æ±‚â€œæ¯æ¬¡è‡³å¤š 1KBâ€ä¸€è‡´ï¼›
  * `read_file_data()` / `write_file_data()` / `pkcs7_padding()` / `pkcs7_unpadding()` / AES-CBC ä¾‹ç¨‹å…¨éƒ¨å¤ç”¨ï¼›
  * åŸâ€œæ–‡ä»¶æ¨¡å¼â€æ‰“å°ä¸çŠ¶æ€åˆ‡æ¢ã€èœå•å…¥å£ã€ä¸²å£é…ç½®ç­‰ç»´æŒä¸å˜ï¼Œä»…æŠŠå¤„ç†æ ¸å¿ƒæ¢æˆæµå¼å‡½æ•°ã€‚

---

å¦‚æœæ‚¨å¸Œæœ›æŠŠ **IV** å‡çº§ä¸ºâ€œæ¯æ¬¡åŠ å¯†éšæœºç”Ÿæˆå¹¶å†™å…¥ `ciphertext.txt` å¤´éƒ¨â€çš„å®‰å…¨å®è·µï¼Œæˆ‘å¯ä»¥åœ¨ä¸Šè¿°åŸºç¡€ä¸Šå†ç»™å‡º**æœ€å°å¢æ”¹è¡¥ä¸**ï¼ˆPython å†™å…¥/è¯»å– 16 å­—èŠ‚ IVï¼ŒMCU ç¬¬ä¸€å¸§è¯»å– `IVHEX:...` æˆ–äºŒè¿›åˆ¶ 16 å­—èŠ‚ï¼‰ï¼Œæµç¨‹ä¸å˜ã€‚

â€”

**å¼•ç”¨æ ‡æ³¨**ï¼š

* Python ç°æœ‰æ¡æ‰‹/æ¨¡å¼/åè®®ä¸åˆ†å—å‘é€ã€å…³é”®æç¤ºè¯çš„æ£€æµ‹ç­‰å‡æ¥è‡ªæ‚¨ç»™å‡ºçš„è„šæœ¬ã€‚
* MCU çš„ç¼“å†²åŒºå®ã€ä¸²å£ I/Oã€èœå•/æ¨¡å¼æ¡†æ¶ã€AES-CBC ä¸ PKCS#7 å‡½æ•°å‡æ¥è‡ªæ‚¨ç»™å‡ºçš„å›ºä»¶ä»£ç ã€‚
