# Serial File Transport.py - More Robust Version
# 目前成功的启动方法：先复位MCU，2秒后再启动脚本
import serial
import time
import os

def simple_mcu_handshake(ser, timeout=10):
    """Enhanced MCU handshake protocol with dedicated trigger byte"""
    print("Performing handshake...")
    start_time = time.time()
    
    # 清空缓冲区
    ser.reset_input_buffer()
    ser.reset_output_buffer()
    time.sleep(2)  # Increased sleep to allow MCU boot and startup prints
    
    # Send a neutral byte to trigger handshake without consuming mode choice
    ser.write(b'\n')
    time.sleep(0.5)
    
    response_buffer = b""
    # 等待MCU的菜单或提示
    while time.time() - start_time < timeout:
        if ser.in_waiting > 0:
            chunk = ser.read(ser.in_waiting)
            response_buffer += chunk
            text_response = chunk.decode('utf-8', errors='ignore')
            print(f"MCU: {repr(text_response)}")
            
            if 'Choose mode' in text_response or 'Options' in text_response:
                print("MCU ready")
                return True
            if 'MCU Startup' in text_response:
                print("MCU startup detected")
        time.sleep(0.1)
    
    # 如果超时，打印累积响应并继续
    print(f"Handshake timeout. Accumulated response: {repr(response_buffer.decode('utf-8', errors='ignore'))}")
    return False  # Changed to False on timeout for stricter handling

def send_file(port, filename):
    # 读取文件内容
    with open(filename, 'rb') as f:
        data = f.read()
    
    file_size = len(data)
    print(f"Sending file: {filename} ({file_size} bytes)")
    
    try:
        ser = serial.Serial(port, 115200, timeout=5, dsrdtr=False)  # Disable DSR/DTR to avoid unintended resets
        print(f"Port {port} opened")
        
        # 等待MCU准备就绪
        if not simple_mcu_handshake(ser):
            print("Handshake failed, aborting")
            ser.close()
            return
        
        # 发送模式选择 'f'
        print("Selecting file mode...")
        ser.write(b'f')
        time.sleep(1)  # Increased sleep after mode selection
        
        # 检查MCU是否进入文件模式 (updated to match simplified MCU prints)
        response_buffer = b""
        start_time = time.time()
        timeout = 10  # Increased timeout
        while time.time() - start_time < timeout:
            if ser.in_waiting > 0:
                chunk = ser.read(ser.in_waiting)
                response_buffer += chunk
                if b'Starting File-based' in response_buffer or b'Ready to receive file' in response_buffer or b'AES CBC WITH PROTOCOL' in response_buffer:
                    print("MCU in file mode")
                    break
            time.sleep(0.1)
        
        if b'Starting File-based' not in response_buffer and b'Ready to receive file' not in response_buffer and b'AES CBC WITH PROTOCOL' not in response_buffer:
            print(f"Failed to enter file mode. Accumulated response: {repr(response_buffer.decode('utf-8', errors='ignore'))}")
            ser.close()
            return
        
        # 发送协议头
        header = f"SIZE:{file_size}\n".encode('utf-8')
        print(f"Sending header: {header.decode('utf-8').strip()}")
        ser.write(header)
        time.sleep(1)
        
        # 发送文件数据
        chunk_size = 16
        sent_bytes = 0
        
        print("Sending file data...")
        for i in range(0, len(data), chunk_size):
            chunk = data[i:i+chunk_size]
            ser.write(chunk)
            sent_bytes += len(chunk)
            
            progress = (sent_bytes / file_size) * 100
            print(f"Progress: {progress:.1f}%")
            time.sleep(0.1)
        
        # 发送结束标记
        end_marker = b"END\n"
        print(f"File sent, sending end marker")
        ser.write(end_marker)
        
        # 接收处理结果
        print("Waiting for MCU processing...")
        full_response = b""
        start_time = time.time()
        processing_complete = False
        timeout = 30
        
        while time.time() - start_time < timeout:
            if ser.in_waiting > 0:
                chunk = ser.read(ser.in_waiting)
                full_response += chunk
                
                # 实时显示接收到的内容
                try:
                    text_chunk = chunk.decode('utf-8', errors='ignore')
                    for line in text_chunk.split('\n'):
                        if line.strip():
                            print(f"MCU: {line}")
                except:
                    pass
                
                # 检查处理是否完成
                if b'PROCESSING SUMMARY' in full_response and b'completed' in full_response:  # Updated to match simplified
                    print("MCU processing completed")
                    processing_complete = True
                    break
            time.sleep(0.1)
        
        if not processing_complete:
            print("Processing timeout")
            print(f"Accumulated response: {repr(full_response.decode('utf-8', errors='ignore'))}")
        
        # 显示完整响应
        print("\nFULL MCU RESPONSE")
        try:
            print(full_response.decode('utf-8', errors='ignore'))
        except:
            print(full_response.hex())
        
    except Exception as e:
        print(f"Error: {e}")
    finally:
        if 'ser' in locals():
            ser.close()
            print("Port closed")

def main():
    port = "COM3"
    filename = "testfile.txt"
    
    if not os.path.exists(filename):
        print(f"File does not exist: {filename}")
        return
    
    # 检查端口是否可用
    try:
        test_ser = serial.Serial(port, 115200, timeout=1, dsrdtr=False)
        test_ser.close()
        print(f"Port {port} available")
    except Exception as e:
        print(f"Cannot access port {port}: {e}")
        return
    
    send_file(port, filename)

if __name__ == "__main__":
    main()# Serial File Transport.py - More Robust Version
# 目前成功的启动方法：先复位MCU，2秒后再启动脚本
import serial
import time
import os

def simple_mcu_handshake(ser, timeout=10):
    """Enhanced MCU handshake protocol with dedicated trigger byte"""
    print("Performing handshake...")
    start_time = time.time()
    
    # 清空缓冲区
    ser.reset_input_buffer()
    ser.reset_output_buffer()
    time.sleep(2)  # Increased sleep to allow MCU boot and startup prints
    
    # Send a neutral byte to trigger handshake without consuming mode choice
    ser.write(b'\n')
    time.sleep(0.5)
    
    response_buffer = b""
    # 等待MCU的菜单或提示
    while time.time() - start_time < timeout:
        if ser.in_waiting > 0:
            chunk = ser.read(ser.in_waiting)
            response_buffer += chunk
            text_response = chunk.decode('utf-8', errors='ignore')
            print(f"MCU: {repr(text_response)}")
            
            if 'Choose mode' in text_response or 'Options' in text_response:
                print("MCU ready")
                return True
            if 'MCU Startup' in text_response:
                print("MCU startup detected")
        time.sleep(0.1)
    
    # 如果超时，打印累积响应并继续
    print(f"Handshake timeout. Accumulated response: {repr(response_buffer.decode('utf-8', errors='ignore'))}")
    return False  # Changed to False on timeout for stricter handling

def send_file(port, filename):
    # 读取文件内容
    with open(filename, 'rb') as f:
        data = f.read()
    
    file_size = len(data)
    print(f"Sending file: {filename} ({file_size} bytes)")
    
    try:
        ser = serial.Serial(port, 115200, timeout=5, dsrdtr=False)  # Disable DSR/DTR to avoid unintended resets
        print(f"Port {port} opened")
        
        # 等待MCU准备就绪
        if not simple_mcu_handshake(ser):
            print("Handshake failed, aborting")
            ser.close()
            return
        
        # 发送模式选择 'f'
        print("Selecting file mode...")
        ser.write(b'f')
        time.sleep(1)  # Increased sleep after mode selection
        
        # 检查MCU是否进入文件模式 (updated to match simplified MCU prints)
        response_buffer = b""
        start_time = time.time()
        timeout = 10  # Increased timeout
        while time.time() - start_time < timeout:
            if ser.in_waiting > 0:
                chunk = ser.read(ser.in_waiting)
                response_buffer += chunk
                if b'Starting File-based' in response_buffer or b'Ready to receive file' in response_buffer or b'AES CBC WITH PROTOCOL' in response_buffer:
                    print("MCU in file mode")
                    break
            time.sleep(0.1)
        
        if b'Starting File-based' not in response_buffer and b'Ready to receive file' not in response_buffer and b'AES CBC WITH PROTOCOL' not in response_buffer:
            print(f"Failed to enter file mode. Accumulated response: {repr(response_buffer.decode('utf-8', errors='ignore'))}")
            ser.close()
            return
        
        # 发送协议头
        header = f"SIZE:{file_size}\n".encode('utf-8')
        print(f"Sending header: {header.decode('utf-8').strip()}")
        ser.write(header)
        time.sleep(1)
        
        # 发送文件数据
        chunk_size = 16
        sent_bytes = 0
        
        print("Sending file data...")
        for i in range(0, len(data), chunk_size):
            chunk = data[i:i+chunk_size]
            ser.write(chunk)
            sent_bytes += len(chunk)
            
            progress = (sent_bytes / file_size) * 100
            print(f"Progress: {progress:.1f}%")
            time.sleep(0.1)
        
        # 发送结束标记
        end_marker = b"END\n"
        print(f"File sent, sending end marker")
        ser.write(end_marker)
        
        # 接收处理结果
        print("Waiting for MCU processing...")
        full_response = b""
        start_time = time.time()
        processing_complete = False
        timeout = 30
        
        while time.time() - start_time < timeout:
            if ser.in_waiting > 0:
                chunk = ser.read(ser.in_waiting)
                full_response += chunk
                
                # 实时显示接收到的内容
                try:
                    text_chunk = chunk.decode('utf-8', errors='ignore')
                    for line in text_chunk.split('\n'):
                        if line.strip():
                            print(f"MCU: {line}")
                except:
                    pass
                
                # 检查处理是否完成
                if b'PROCESSING SUMMARY' in full_response and b'completed' in full_response:  # Updated to match simplified
                    print("MCU processing completed")
                    processing_complete = True
                    break
            time.sleep(0.1)
        
        if not processing_complete:
            print("Processing timeout")
            print(f"Accumulated response: {repr(full_response.decode('utf-8', errors='ignore'))}")
        
        # 显示完整响应
        print("\nFULL MCU RESPONSE")
        try:
            print(full_response.decode('utf-8', errors='ignore'))
        except:
            print(full_response.hex())
        
    except Exception as e:
        print(f"Error: {e}")
    finally:
        if 'ser' in locals():
            ser.close()
            print("Port closed")

def main():
    port = "COM3"
    filename = "testfile.txt"
    
    if not os.path.exists(filename):
        print(f"File does not exist: {filename}")
        return
    
    # 检查端口是否可用
    try:
        test_ser = serial.Serial(port, 115200, timeout=1, dsrdtr=False)
        test_ser.close()
        print(f"Port {port} available")
    except Exception as e:
        print(f"Cannot access port {port}: {e}")
        return
    
    send_file(port, filename)

if __name__ == "__main__":
    main()